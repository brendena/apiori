{"filter":false,"title":"LinkedList.h","tooltip":"/header_files/LinkedList.h","undoManager":{"mark":14,"position":14,"stack":[[{"group":"doc","deltas":[{"start":{"row":0,"column":0},"end":{"row":325,"column":6},"action":"remove","lines":["/*","errorlog","possible error with bool Operator++","","*/","#ifndef LINKED_LIST","#define LINKED_LIST","","#include <iostream>","#include <stdlib.h> //atio","#include \"Node.h\"","using namespace std;","","template <class T>","class LinkedList","{","    private:","        Node<T> *mHead, *mTail, *iterator;","        int     mCount;","    public:","    ","    //getters","    \tint  getCount();  //works","    \tT    getData(int index);","    \tNode<T>* getHead(){ return mHead;};","    \t","    //setters","    \tvoid setData(int index, T data);","\t\tvoid createArray(int size);","    \tvoid setArrayData(int index, int data);","    \t"," \t//utilities","    \tvoid clear();","    \tvoid display();","    \tbool isEmpty();","    \tbool dealWithAddingValuesToBeginning(Node<T>* value);","    \tvoid appendToTheEnd(Node<T>* value);","    \tbool search(int value);","    \tvoid print();","    //dealing with iterator","    \tvoid clearIterator();","\t\tint getIteratorSize();","\t\tT* getIteratorValue();","\t\t","    //operttor//constructors","    \tT operator[](int index);","    \tbool operator++(int value); /************ added the int value and it compiled May not work *********************/","    \t","    \tLinkedList<T> operator=(LinkedList<T> other);","    \t","    \tLinkedList();","    \t~LinkedList();","    \t","};","","template <class T>","LinkedList<T>::LinkedList()","{","\tmHead = NULL;","\tmTail = NULL;","\titerator = NULL;","\tmCount = 0;","}","","template <class T>","LinkedList<T>::~LinkedList()","{","   clear();","}","","template <class T>","int LinkedList<T>::getCount()","{","\treturn mCount;","}","","template <class T>","T LinkedList<T>::getData(int index)","{","\tNode<T>* ptrIterator = mHead;","\tfor (int i = 0; i < index; i++)","\t{","\t\tptrIterator = ptrIterator->mNext;","\t}","\treturn ptrIterator->mData;","}","","template <class T>","void LinkedList<T>::setData(int index, T data)  ///really bad implementation","{","\tif (mCount < index)","\t{ ","\t\tcout << \"this is a no no \" << endl; ","\t}","\telse if (mHead == NULL)","\t{","\t\tmHead = new Node<T>(data);","\t\tmTail = mHead;","\t}","\telse{","\t\tNode<T>* tmp = mHead;","\t\tfor (int i = 0; tmp->mNext != NULL && index == i; i++)//get the node right before the index","\t\t{","\t\t\ttmp = tmp->mNext;","\t\t}","\t}","}","","","template <class T>","void LinkedList<T>::clear()  //doesn't work","{","\tNode<T> *nodePtr = mHead;","\twhile(nodePtr != NULL)","\t{","\t  //garbage keeps track of node to be deleted","\t  Node<T> *garbage = nodePtr;","\t  //move on to the next node, if any","\t  nodePtr = nodePtr->mNext;","\t  delete garbage;","\t}","\t","\tdelete mHead;","\tdelete mTail;","\tmHead = mTail = NULL;","\tmCount = 0;","}","","","template <class T>","T LinkedList<T>::operator[](int index)","{","\tNode<T>* ptrIterator = mHead;","\tfor (int i = 0; i < index && ptrIterator->mNext != NULL; i++)","\t{","\t\tptrIterator = ptrIterator->mNext;","\t}","\treturn ptrIterator->mData;","}","","","/*","pre:","Post:","Purpose: is to keep a position","*/","template <class T>","bool LinkedList<T>::operator++(int value)","{","\t","\tif(isEmpty())","\t{","\t\tcout << \"empty \\n\";","\t\treturn 0;","\t}","\telse","\t{","\t\tcout << \"iterator value \" << iterator->mData[0] << \"\\n\"; ","\t\titerator = iterator->mNext;","\t}","\tif(iterator == NULL)","\t{","\t\tcout << \"null\\n\";","\t\treturn 0;","\t}","\telse","\t{","\t\treturn 1;","\t}","\t","\t//return false;  this works","}","","template <class T>","bool LinkedList<T>::isEmpty()","{","\treturn mHead == NULL;","}","","/*","pre:size of the array","Post: is to then add the items to the array","purpose:","the purpose is to make the tail ready to add the elements to.  ","We want the tail to be ready because where allways going to be adding onto the tail.","*/","template <class T>","void LinkedList<T>::createArray(int size)","{","\tNode<T>* newNode = new Node<T>(size);","\tappendToTheEnd(newNode);","}","template <class T>","void LinkedList<T>::setArrayData(int index, int data)","{","\tmTail->mData[index] = data;","}","","","template <class T>","void LinkedList<T>::clearIterator()","{","\titerator = mHead;","}","","template <class T>","int LinkedList<T>::getIteratorSize()","{","\treturn iterator->mSize;\t","}","","template <class T>","T* LinkedList<T>::getIteratorValue()","{","\treturn iterator->mData;","}","","/*","pre: just a value","post:  return a true if its been added else returns false","purpose:  is to create the first 2 values of the linked list","","// might be a problem if the number come up twice first go////////","*/","template <class T>","bool LinkedList<T>::dealWithAddingValuesToBeginning(Node<T>* value)","{","\tif(mHead == NULL)","\t{","\t\tmHead = value;","\t\tmTail = mHead;","\t\tmCount++;","\t\treturn true;","\t}","\telse if(mHead == mTail)","\t{","\t\tmHead->mNext = value;","\t\tmTail = mHead->mNext;","\t\tmCount++;","\t\treturn true;","\t}","\treturn false;","}","","template <class T>","void LinkedList<T>::appendToTheEnd(Node<T>* value)","{","\tif(!dealWithAddingValuesToBeginning(value))","\t{","\t\tmTail->mNext = value;","\t\tmTail = mTail->mNext;","\t}","}","","template <class T>","bool LinkedList<T>::search(int value)","{","\tNode<T>* ptr = mHead;","","\twhile(ptr != NULL)","\t{","\t\tfor(int i = 0; i < ptr->mSize + 1; i++)","\t\t{","\t\t\tif(value == ptr->mData[i])","\t\t\t{","\t\t\t\treturn true;","\t\t\t}","\t\t}","\t\tptr = ptr->mNext;","\t}","\treturn false;","}","","","template <class T>","void LinkedList<T>::display()","{","\tNode<T>* ptr = mHead;","\tint sizeArray;","\tcout << \"\\ndisplay\\n\";","\tfor (int i = 0; ptr != NULL; i++)","\t{","\t\tcout << \"\\n\\n\\nobjects number \" << i;","\t\tfor(int i = 0; i <= ptr->mSize; i++)","\t\t{","\t\t\tcout << \"data \" << ptr->mData[i] << endl;","\t\t}","\t\tptr = ptr->mNext;","\t}","}","/*","pre:","post: ","purpose: to copy the linked list to another array","*/","template <class T>","LinkedList<T> LinkedList<T>::operator=(LinkedList other)","{","\tclear();","\t","\tmHead = other.getHead();","}","","","/*","don't we want the frequency count when we print out","*/","template <class T>","void LinkedList<T>::print()","{","\tofstream myfile;","\tmyfile.open (\"output.txt\");","\tNode<T>* ptr = mHead;","\twhile(ptr != NULL)","\t{","\t\tfor(int i = 0; i <= ptr->mSize; i++)","\t\t{","\t\t\tmyfile << ptr->mData[i] << \"  \";","\t\t}","\t\tmyfile << \"\\n\";","\t\tptr = ptr->mNext;","\t}","\t","}","","#endif"]},{"start":{"row":0,"column":0},"end":{"row":325,"column":6},"action":"insert","lines":["/*","errorlog","possible error with bool Operator++","","*/","#ifndef LINKED_LIST","#define LINKED_LIST","","#include <iostream>","#include <stdlib.h> //atio","#include \"Node.h\"","using namespace std;","","template <class T>","class LinkedList","{","    private:","        Node<T> *mHead, *mTail, *iterator;","        int     mCount;","    public:","    ","    //getters","    \tint  getCount();  //works","    \tT    getData(int index);","    \tNode<T>* getHead(){ return mHead;};","    \t","    //setters","    \tvoid setData(int index, T data);","\t\tvoid createArray(int size);","    \tvoid setArrayData(int index, int data);","    \t"," \t//utilities","    \tvoid clear();","    \tvoid display();","    \tbool isEmpty();","    \tbool dealWithAddingValuesToBeginning(Node<T>* value);","    \tvoid appendToTheEnd(Node<T>* value);","    \tbool search(int value);","    \tvoid print();","    //dealing with iterator","    \tvoid clearIterator();","\t\tint getIteratorSize();","\t\tT* getIteratorValue();","\t\t","    //operttor//constructors","    \tT operator[](int index);","    \tbool operator++(int value); /************ added the int value and it compiled May not work *********************/","    \t","    \tLinkedList<T> operator=(LinkedList<T> other);","    \t","    \tLinkedList();","    \t~LinkedList();","    \t","};","","template <class T>","LinkedList<T>::LinkedList()","{","\tmHead = NULL;","\tmTail = NULL;","\titerator = NULL;","\tmCount = 0;","}","","template <class T>","LinkedList<T>::~LinkedList()","{","   clear();","}","","template <class T>","int LinkedList<T>::getCount()","{","\treturn mCount;","}","","template <class T>","T LinkedList<T>::getData(int index)","{","\tNode<T>* ptrIterator = mHead;","\tfor (int i = 0; i < index; i++)","\t{","\t\tptrIterator = ptrIterator->mNext;","\t}","\treturn ptrIterator->mData;","}","","template <class T>","void LinkedList<T>::setData(int index, T data)  ///really bad implementation","{","\tif (mCount < index)","\t{ ","\t\tcout << \"this is a no no \" << endl; ","\t}","\telse if (mHead == NULL)","\t{","\t\tmHead = new Node<T>(data);","\t\tmTail = mHead;","\t}","\telse{","\t\tNode<T>* tmp = mHead;","\t\tfor (int i = 0; tmp->mNext != NULL && index == i; i++)//get the node right before the index","\t\t{","\t\t\ttmp = tmp->mNext;","\t\t}","\t}","}","","","template <class T>","void LinkedList<T>::clear()  //doesn't work","{","\tNode<T> *nodePtr = mHead;","\twhile(nodePtr != NULL)","\t{","\t  //garbage keeps track of node to be deleted","\t  Node<T> *garbage = nodePtr;","\t  //move on to the next node, if any","\t  nodePtr = nodePtr->mNext;","\t  delete garbage;","\t}","\t","\tdelete mHead;","\tdelete mTail;","\tmHead = mTail = NULL;","\tmCount = 0;","}","","","template <class T>","T LinkedList<T>::operator[](int index)","{","\tNode<T>* ptrIterator = mHead;","\tfor (int i = 0; i < index && ptrIterator->mNext != NULL; i++)","\t{","\t\tptrIterator = ptrIterator->mNext;","\t}","\treturn ptrIterator->mData;","}","","","/*","pre:","Post:","Purpose: is to keep a position","*/","template <class T>","bool LinkedList<T>::operator++(int value)","{","\t","\tif(isEmpty())","\t{","\t\tcout << \"empty \\n\";","\t\treturn 0;","\t}","\telse","\t{","\t\tcout << \"iterator value \" << iterator->mData[0] << \"\\n\"; ","\t\titerator = iterator->mNext;","\t}","\tif(iterator == NULL)","\t{","\t\tcout << \"null\\n\";","\t\treturn 0;","\t}","\telse","\t{","\t\treturn 1;","\t}","\t","\t//return false;  this works","}","","template <class T>","bool LinkedList<T>::isEmpty()","{","\treturn mHead == NULL;","}","","/*","pre:size of the array","Post: is to then add the items to the array","purpose:","the purpose is to make the tail ready to add the elements to.  ","We want the tail to be ready because where allways going to be adding onto the tail.","*/","template <class T>","void LinkedList<T>::createArray(int size)","{","\tNode<T>* newNode = new Node<T>(size);","\tappendToTheEnd(newNode);","}","template <class T>","void LinkedList<T>::setArrayData(int index, int data)","{","\tmTail->mData[index] = data;","}","","","template <class T>","void LinkedList<T>::clearIterator()","{","\titerator = mHead;","}","","template <class T>","int LinkedList<T>::getIteratorSize()","{","\treturn iterator->mSize;\t","}","","template <class T>","T* LinkedList<T>::getIteratorValue()","{","\treturn iterator->mData;","}","","/*","pre: just a value","post:  return a true if its been added else returns false","purpose:  is to create the first 2 values of the linked list","","// might be a problem if the number come up twice first go////////","*/","template <class T>","bool LinkedList<T>::dealWithAddingValuesToBeginning(Node<T>* value)","{","\tif(mHead == NULL)","\t{","\t\tmHead = value;","\t\tmTail = mHead;","\t\tmCount++;","\t\treturn true;","\t}","\telse if(mHead == mTail)","\t{","\t\tmHead->mNext = value;","\t\tmTail = mHead->mNext;","\t\tmCount++;","\t\treturn true;","\t}","\treturn false;","}","","template <class T>","void LinkedList<T>::appendToTheEnd(Node<T>* value)","{","\tif(!dealWithAddingValuesToBeginning(value))","\t{","\t\tmTail->mNext = value;","\t\tmTail = mTail->mNext;","\t}","}","","template <class T>","bool LinkedList<T>::search(int value)","{","\tNode<T>* ptr = mHead;","","\twhile(ptr != NULL)","\t{","\t\tfor(int i = 0; i < ptr->mSize + 1; i++)","\t\t{","\t\t\tif(value == ptr->mData[i])","\t\t\t{","\t\t\t\treturn true;","\t\t\t}","\t\t}","\t\tptr = ptr->mNext;","\t}","\treturn false;","}","","","template <class T>","void LinkedList<T>::display()","{","\tNode<T>* ptr = mHead;","\tint sizeArray;","\tcout << \"\\ndisplay\\n\";","\tfor (int i = 0; ptr != NULL; i++)","\t{","\t\tcout << \"\\n\\n\\nobjects number \" << i;","\t\tfor(int i = 0; i <= ptr->mSize; i++)","\t\t{","\t\t\tcout << \"data \" << ptr->mData[i] << endl;","\t\t}","\t\tptr = ptr->mNext;","\t}","}","/*","pre:","post: ","purpose: to copy the linked list to another array","*/","template <class T>","LinkedList<T> LinkedList<T>::operator=(LinkedList other)","{","\tclear();","\t","\tmHead = other.getHead();","}","","","/*","don't we want the frequency count when we print out","*/","template <class T>","void LinkedList<T>::print()","{","\tofstream myfile;","\tmyfile.open (\"output.txt\");","\tNode<T>* ptr = mHead;","\twhile(ptr != NULL)","\t{","\t\tfor(int i = 0; i <= ptr->mSize; i++)","\t\t{","\t\t\tmyfile << ptr->mData[i] << \"  \";","\t\t}","\t\tmyfile << \"\\n\";","\t\tptr = ptr->mNext;","\t}","\t","}","","#endif"]}]}],[{"group":"doc","deltas":[{"start":{"row":261,"column":31},"end":{"row":261,"column":35},"action":"remove","lines":[" + 1"]}]}],[{"group":"doc","deltas":[{"start":{"row":283,"column":20},"end":{"row":283,"column":21},"action":"remove","lines":["="]}]}],[{"group":"doc","deltas":[{"start":{"row":315,"column":20},"end":{"row":315,"column":21},"action":"remove","lines":["="]}]}],[{"group":"doc","deltas":[{"start":{"row":282,"column":32},"end":{"row":282,"column":33},"action":"insert","lines":["\\"]}]}],[{"group":"doc","deltas":[{"start":{"row":282,"column":33},"end":{"row":282,"column":34},"action":"insert","lines":["n"]}]}],[{"group":"doc","deltas":[{"start":{"row":282,"column":32},"end":{"row":282,"column":34},"action":"remove","lines":["\\n"]}]}],[{"group":"doc","deltas":[{"start":{"row":282,"column":38},"end":{"row":282,"column":39},"action":"insert","lines":[" "]}]}],[{"group":"doc","deltas":[{"start":{"row":282,"column":39},"end":{"row":282,"column":40},"action":"insert","lines":["<"]}]}],[{"group":"doc","deltas":[{"start":{"row":282,"column":40},"end":{"row":282,"column":41},"action":"insert","lines":["<"]}]}],[{"group":"doc","deltas":[{"start":{"row":282,"column":41},"end":{"row":282,"column":42},"action":"insert","lines":[" "]}]}],[{"group":"doc","deltas":[{"start":{"row":282,"column":42},"end":{"row":282,"column":43},"action":"insert","lines":["e"]}]}],[{"group":"doc","deltas":[{"start":{"row":282,"column":43},"end":{"row":282,"column":44},"action":"insert","lines":["n"]}]}],[{"group":"doc","deltas":[{"start":{"row":282,"column":44},"end":{"row":282,"column":45},"action":"insert","lines":["d"]}]}],[{"group":"doc","deltas":[{"start":{"row":282,"column":45},"end":{"row":282,"column":46},"action":"insert","lines":["l"]}]}]]},"ace":{"folds":[],"scrolltop":4207.000350952148,"scrollleft":0,"selection":{"start":{"row":282,"column":46},"end":{"row":282,"column":46},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":251,"state":"start","mode":"ace/mode/c_cpp"}},"timestamp":1417708661318,"hash":"b2aca1f7c12ba5a489bcde1e2bab374517ca0d69"}