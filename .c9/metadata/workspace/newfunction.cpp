{"changed":true,"filter":false,"title":"newfunction.cpp","tooltip":"/newfunction.cpp","value":"\n//constructor\ntemplate <typename T>\nclass AssList\n{\npublic:\n   Node<T>* mHead;\n   Node<T>* mTail;\n   int mCount;\n   \n};\n\n//adds new nodes to new list\nvoid makeSets(linkedList oldList, linkedList newList, int minFrequ)\n{\n   Node<T>* temp1;\n   Node<T>* temp2;\n   Node<T>* newListTemp = newList.mHead;\n   temp2 = oldList.mHead;\n   \n   while(temp2->mNext != NULL)\n   {\n      temp1 = temp2;\n      temp2 = temp2->mNext;\n      \n      if(isSame(temp1, temp2))\n         if(newList.mHead == NULL)\n            newList.mHead = makeNewNode(temp1, temp2);\n         else\n         {\n            newListTemp = newListTemp->mNext;\n            newListTemp = makeNewNode(temp1, temp2);\n         }\n   }\n}\n\n//adds data to the new node\nNode<T> makeNewNode(Node<T>* temp1, Node<T>* temp2)\n{\n   Node<T>* newNode = new Node<T>;\n   newNode->mSize = size + 1;\n\n   for(int i = 0; i < size; i++)\n   {\n      newNode->mData[i] = temp1->mData[i]\n   }\n   newNode->mData[newNode->mSize - 1] = temp2->mData[temp2->mSize - 1];\n   \n}\n\n//checks to see if all elements in sets are the same except for last element\nbool isSame(Node<T>* temp1, Node<T>* temp2)\n{\n   bool theSame = true;\n   \n   for(int i = 0; i < temp1->mSize; i++)\n   {\n      if(temp1->mData[i] != temp2->mData[i] && i < temp1->mSize - 1)\n         theSame = false;\n   }\n   \n   return theSame;\n}\n\nvoid AssList::prune(AssList oldList)\n{\n\tNode* currNode = mHead;\n\tNode* lastNode;\n\twhile(currNode != NULL)\n\t{\n\tfor(int i = 0; i < oldList.mCount; i++)\n\t{\n\t\t\tfor(int j = 0; j < mSize; j++)\n\t\t\t{\n\t\t\t\tT* subset = new T[mSize - 1];\n\t\t\t\tfor(int k = 0; k < mSize - 1; k++)\n\t\t\t\t{\n\t\t\t\t\tif(k < j)\n\t\t\t\t\t{\n\t\t\t\t\t\tsubset[k] = currNode->mSet[k];\n\t\t\t\t\t}\t\t\t\t\n                        if(k > j)\n\t\t\t\t\t{\n\t\t\t\t\t\tsubset[k] = currNode->mSet[k + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tNode* subsetNode = new Node(subset);\n\t\t\t\tif(!oldList.checkListForNode(subsetNode))\n\t\t\t\t{\n\t\t\t\t\tNode* tmp = currNode;\n\t\t\t\t\tcurrNode = currNode.mNext;\n\t\t\t\t\tif(i == 0) mHead = currNode;\n\t\t\t\t\telse lastNode.mNext = currNode;\n\t\t\t\t\tdelete tmp;\n\t\t\t}\n\t\t}\n\t}\n\tlastNode = currNode;\n\tcurrNode = currNode->mNext;;\n\t}\n}\n","undoManager":{"mark":-1,"position":5,"stack":[[{"group":"doc","deltas":[{"start":{"row":81,"column":0},"end":{"row":81,"column":4},"action":"insert","lines":["    "]}]}],[{"group":"doc","deltas":[{"start":{"row":81,"column":4},"end":{"row":81,"column":8},"action":"insert","lines":["    "]}]}],[{"group":"doc","deltas":[{"start":{"row":81,"column":8},"end":{"row":81,"column":12},"action":"insert","lines":["    "]}]}],[{"group":"doc","deltas":[{"start":{"row":81,"column":12},"end":{"row":81,"column":16},"action":"insert","lines":["    "]}]}],[{"group":"doc","deltas":[{"start":{"row":81,"column":16},"end":{"row":81,"column":20},"action":"insert","lines":["    "]}]}],[{"group":"doc","deltas":[{"start":{"row":81,"column":20},"end":{"row":81,"column":24},"action":"insert","lines":["    "]}]}]]},"ace":{"folds":[],"scrolltop":597,"scrollleft":0,"selection":{"start":{"row":81,"column":24},"end":{"row":81,"column":24},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":0},"timestamp":1417562822745}